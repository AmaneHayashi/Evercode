# 基于SARIMAX模型的北京市月度快递业务总量预测分析

- [基于SARIMAX模型的北京市月度快递业务总量预测分析](#%e5%9f%ba%e4%ba%8esarimax%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%8c%97%e4%ba%ac%e5%b8%82%e6%9c%88%e5%ba%a6%e5%bf%ab%e9%80%92%e4%b8%9a%e5%8a%a1%e6%80%bb%e9%87%8f%e9%a2%84%e6%b5%8b%e5%88%86%e6%9e%90)
  - [1. Python基础](#1-python%e5%9f%ba%e7%a1%80)
    - [1.1 基本语法](#11-%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95)
      - [1.1.1 脚本命令](#111-%e8%84%9a%e6%9c%ac%e5%91%bd%e4%bb%a4)
      - [1.1.2 语言特点](#112-%e8%af%ad%e8%a8%80%e7%89%b9%e7%82%b9)
      - [1.1.3 编码方式](#113-%e7%bc%96%e7%a0%81%e6%96%b9%e5%bc%8f)
      - [1.1.4 标识符](#114-%e6%a0%87%e8%af%86%e7%ac%a6)
      - [1.1.5 保留字](#115-%e4%bf%9d%e7%95%99%e5%ad%97)
      - [1.1.6 注释](#116-%e6%b3%a8%e9%87%8a)
      - [1.1.7 缩进、空行](#117-%e7%bc%a9%e8%bf%9b%e7%a9%ba%e8%a1%8c)
      - [1.1.8 分号](#118-%e5%88%86%e5%8f%b7)
      - [1.1.9 代码组与子句](#119-%e4%bb%a3%e7%a0%81%e7%bb%84%e4%b8%8e%e5%ad%90%e5%8f%a5)
      - [1.1.10 导入](#1110-%e5%af%bc%e5%85%a5)
    - [1.2 数据类型](#12-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b)
      - [1.2.1 变量赋值](#121-%e5%8f%98%e9%87%8f%e8%b5%8b%e5%80%bc)
      - [1.2.2 标准数据类型](#122-%e6%a0%87%e5%87%86%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b)
      - [1.2.3 基本数据类型简介](#123-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%ae%80%e4%bb%8b)
    - [1.3 运算符](#13-%e8%bf%90%e7%ae%97%e7%ac%a6)
      - [1.3.1 算术运算符](#131-%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e7%ac%a6)
      - [1.3.2 比较运算符](#132-%e6%af%94%e8%be%83%e8%bf%90%e7%ae%97%e7%ac%a6)
      - [1.3.3 赋值运算符](#133-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6)
      - [1.3.4 逻辑运算符](#134-%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6)
      - [1.3.5 成员运算符](#135-%e6%88%90%e5%91%98%e8%bf%90%e7%ae%97%e7%ac%a6)
  - [2. 数学基础](#2-%e6%95%b0%e5%ad%a6%e5%9f%ba%e7%a1%80)
    - [2.1 时间序列](#21-%e6%97%b6%e9%97%b4%e5%ba%8f%e5%88%97)
      - [2.1.1 平稳性分析](#211-%e5%b9%b3%e7%a8%b3%e6%80%a7%e5%88%86%e6%9e%90)
      - [2.1.2 自相关与偏自相关](#212-%e8%87%aa%e7%9b%b8%e5%85%b3%e4%b8%8e%e5%81%8f%e8%87%aa%e7%9b%b8%e5%85%b3)
    - [2.2 *Shapiro-Wilk*检验](#22-shapiro-wilk%e6%a3%80%e9%aa%8c)
    - [2.3 *SARIMA*模型](#23-sarima%e6%a8%a1%e5%9e%8b)
      - [2.3.1 定义](#231-%e5%ae%9a%e4%b9%89)
      - [2.3.2 差分](#232-%e5%b7%ae%e5%88%86)
      - [2.3.3 模型特征](#233-%e6%a8%a1%e5%9e%8b%e7%89%b9%e5%be%81)
      - [2.3.4 训练流程](#234-%e8%ae%ad%e7%bb%83%e6%b5%81%e7%a8%8b)
    - [2.3.5 模型选择标准](#235-%e6%a8%a1%e5%9e%8b%e9%80%89%e6%8b%a9%e6%a0%87%e5%87%86)
    - [2.4 误差函数](#24-%e8%af%af%e5%b7%ae%e5%87%bd%e6%95%b0)
      - [2.4.1 *MAPE*函数](#241-mape%e5%87%bd%e6%95%b0)
      - [2.4.2 *MAE*函数](#242-mae%e5%87%bd%e6%95%b0)
  - [3. 代码分析](#3-%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90)
  - [4. 论文建议](#4-%e8%ae%ba%e6%96%87%e5%bb%ba%e8%ae%ae)

## 1. Python基础
### 1.1 基本语法
#### 1.1.1 脚本命令
- `python 文件名.py`：引入解释器执行Python脚本
  - 脚本命令中，`python`也可以写作`python3`
- `python`：进入交互式编程模式`>>>`
  - 可使用`exit()`或`Ctrl+Z`退出交互式编程
#### 1.1.2 语言特点
- **解释型语言**(不用编译，边解释边执行)
- **交互式语言**(在`>>>`后直接执行代码)
- **面向对象语言**(万物皆对象)
- **动态语言**(赋值确定数据类型)
#### 1.1.3 编码方式
- Python3默认采用`UTF-8`编码
#### 1.1.4 标识符
- 第一个字符必须是字母表字母或`_`
- 其它字符可以是字母、数字、下划线
- 大小写敏感
- 可以用中文作变量名
#### 1.1.5 保留字
- 保留字集合：`False`, `None`, `True`, `and`, `as`, `assert`, `break`, `class`, `continue`, `def`, `del`, `elif`, `else`, `except`, `finally`, `for`, `from`, `global`, `if`, `import`, `in`, `is`, `lambda`, `nonlocal`, `not`, `or`, `pass`, `raise`, `return`, `try`, `while`, `with`, `yield`
#### 1.1.6 注释
- 单行注释：以`#`开头
- 多行注释：使用`'''`或`"""`
  ```python
  # -*- coding:utf-8 -*-
  # helloworld.py
  '''
  these are 
  all comments
  '''
  def main():
      print(`hello world!')


  if __name__ == '__main__':
      main()

  #end
  ```
#### 1.1.7 缩进、空行
- 缩进
  - Python中，不需要使用`{}`
  - 程序缩进必须严格符合标准，否则会报错
- 空行
  - 函数之间或类的方法用空行，类与函数入口之间也用空行分隔
  - 空行不是Python语法的一部分，用于分隔不同含义的代码
#### 1.1.8 分号
- Python代码中不需要分号(`;`)即可以表示语句结尾
#### 1.1.9 代码组与子句
- 缩进相同的一组语句构成代码组
    ```python
    if expression : 
        suite
    elif expression : 
        suite
    else :
        suite
    ```
#### 1.1.10 导入
- `import 模块名`：导入整个模块(*module*)
    ```python
    import time
    time.sleep(1)
    ```
- `import 模块名 as 别名`：导入整个模块(*module*)并设置别名
    ```python
    import time as t
    t.sleep(1)
    ```
- `from 模块名 import 函数名[, 函数名]`：导入模块的一个(多个)函数
    ```python
    from time import sleep
    sleep(1)
    ```
- `from 模块名 import *`：导入模块的全部函数
    ```python
    from time import *
    sleep(1)
    ```
### 1.2 数据类型
#### 1.2.1 变量赋值
- 变量不需要声明，使用前必须赋值
- 使用`=`进行赋值
#### 1.2.2 标准数据类型
- 数据类型简介
  - 不可变数据(3个)：`Number`(数字)，`String`(字符串)，`Tuple`(元组)
  - 可变数据(2个)：`List`(列表)，`Dict`(字典)
- 变量类型查询
  - `type(object)`：返回`object`对应的类
    ```python
    a = 1
    print(type(a))
    # 输出：<class 'int'>
    ```
#### 1.2.3 基本数据类型简介
- `Number`
  - 支持`int`，`float`，`bool`，`complex`
  - 数值运算
    - 加法：`+`，`5 + 4 = 9`
    - 减法：`-`，`5 - 4 = 1`
    - 乘法：`*`，`5 * 4 = 20`
    - 除法：`/`，`5 / 4 = 1.25`
    - 地板除：`//`，`5 //4 = 1`
    - 取余：`%`，`5 % 4 = 1`
    - 乘方：`**`，`5 ** 4 = 625`
  - 复数
    - 复数由实部与虚部构成
    - 表示方法：`a + bj`或`complex(a, b)`
  - 其它规则
    - 表达次方时，可以借助`E`或`e`表示：`32.3e+18`，`70E-12`
    - 如果整数部分为0，可以缩写为`.小数`：`.2`，`.1+.2j`
- `String`
  - 使用`'`或`"`括起来，并用`\`转义特殊字符
  - Python没有字符(`char`)类型，一个字符就是长度为1的字符串
- `List`
  - 用 `[ ]` 标识，最通用的复合数据类型
  - 列表中值的切割也可以用到变量 `[头下标:尾下标]` ，就可以截取相应的列表，从左到右索引默认` 0 `开始，从右到左索引默认` -1 `开始，下标可以为空，表示取到头或尾。
![Python列表截取简介](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175046.png)
- `Tuple`
  - 用` () `标识，内部元素用逗号隔开
  - 元组不能二次赋值，相当于只读列表
- `Dict`
  - 用`{ }`标识，最灵活的内置数据结构类型
  - 列表是有序的对象集合，字典是无序的对象集合
  - 字典当中的元素是通过键来存取的：`key -> value`
```python
# Number类型
a = 1
b = 0.2
c = 1+2j
# String类型
d = 'hello world!'
e = "hello world!"
# List类型
f = [1, 2, 3, 4]
g = ['a', 'b', 'c', 'd']
# Tuple类型
h = (1, 2, 3, 4)
# Dict类型
x = {'name':'john','age':24,'nationality':'China'}
```

### 1.3 运算符
> `4 + 5 = 9`，`4`与`5`为操作数，`+`为运算符
#### 1.3.1 算术运算符
- `+`：加法
- `-`：减法
- `*`：乘法
- `/`：除法
- `%`：取模
- `**`：求幂
- `//`：地板除(除法结果下取整)
#### 1.3.2 比较运算符
- `==`：等于
- `!=`：不等于
- `>`：大于
- `<`：小于
- `>=`：大于等于
- `<=`：小于等于
#### 1.3.3 赋值运算符
- `=`：赋值
- `+=`：加赋值
- `-=`：减赋值
- `*=`：乘赋值
- `/=`：除赋值
- `%=`：模赋值
- `**=`：幂赋值
- `//=`：地板除赋值

**Python中没有自增自减运算符！**
```python
i = 1
# 以下这种写法是错误的！
i++
# 正确的写法：
i = i + 1
i += 1
```
#### 1.3.4 逻辑运算符
- `and`：与
- `or`：或
- `not`：非(对于`not x`，如果`x`为`True`，返回`False`，否则返回`True`)
#### 1.3.5 成员运算符
- `in`(如果在指定的序列中找到值返回`True`，否则返回`False`)
- `not in`(如果在指定的序列中找不到值返回`True`，否则返回`False`)
  ```python
  a = 10
  list = [1, 2, 3, 4, 5]
  print(a in list)
  a = 3
  print(a not in list)
  # 分别输出为False, False
  ```
## 2. 数学基础
### 2.1 时间序列
#### 2.1.1 平稳性分析
- 平稳性的定义
![平稳性定义](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175142.png)
- 平稳性的判断
  - 图示法：给出一个随机时间序列，首先可通过该序列的时间路径图来粗略地判断它是否是平稳的。
    - 一个平稳的时间序列在图形上往往表现出一种围绕其均值不断波动的过程
    - 非平稳序列则往往表现出在不同的时间段具有不同的均值(如持续上升或持续下降)
![平稳性示例](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175216.png)
  - *ADF*单位根检验
    - 白噪声是指功率谱密度在整个频域内是常数的噪声。序列的特点表现在任何两个时点的随机变量都不相关,序列中没有任何可以利用的动态规律
![](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175258.png)
![](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175336.png)
![](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175351.png)
![](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175411.png)
![](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175436.png)
    - 单位根：当一个自回归过程中：$y_t=by_{t-1}+a+\epsilon_t$，如果滞后项系数$b$为1，就称为单位根。当单位根存在时，自变量和因变量之间的关系具有欺骗性，因为残差序列的任何误差都不会随着样本量(即时期数)增大而衰减，也就是说模型中的残差的影响是永久的。这种回归又称作伪回归。如果单位根存在，这个过程就是一个随机漫步(*random walk*)。
    - *ADF*检验就是判断序列是否存在单位根：如果序列平稳，就不存在单位根；否则，就会存在单位根。
    - *ADF*检验的 $H_0$假设就是存在单位根，如果得到的显著性检验统计量小于三个置信度$(10\%，5\%，1\%)$，则对应有$(90\%，95\%，99\%)$的把握来拒绝原假设。
- *python*中的*ADF*检验结果分析
  - 代码示例
    ```python
    print sm.tsa.stattools.adfuller(dta)
    # 输出结果如下
    (-9.1916312162314355, 2.1156279593784273e-15, 12, 338, {'5%': -2.8701292813761641, '1%': -3.449846029628477, '10%': -2.5713460670144603}, 4542.1540700410897)
    ```
  - 分析：
    - *ADF*结果是否小于$(10\%，5\%，1\%)$拒绝原假设的统计值：本数据中，*ADF*结果为$-9$， 小于的统计值
    - *P-value*是否非常接近$0$：本数据中，*P-value* 为 $2e^{-15}$，接近$0$
#### 2.1.2 自相关与偏自相关
- 自相关(*autocorrelation*)，也叫序列相关，是一个信号于其自身在不同时间点的互相关。非正式地来说，它就是两次观察之间的相似度对它们之间的时间差的函数。它是找出重复模式(如被噪声掩盖的周期信号)，或识别隐含在信号谐波频率中消失的基频的数学工具。
$$R_k=\frac{\Sigma_{i=1}^{n-k}(X_i−\bar X)(X_{i+k}−\bar X)}{\Sigma_{i=1}^{n}(Xi−\bar X)^2}$$
- 偏自相关(*partial autocorrelation*)：剔除干扰后时间序列观察与先前时间步长时间序列观察之间关系的总结。在滞后k处的偏自相关是在消除由于较短滞后条件导致的任何相关性的影响之后产生的相关性。
$$\rho_{X_t,X_t-k|X_{t-1},...,X_{t-k+1}}=\frac{E[(X_t-\hat EX_t)(X_{t-k}-\hat EX_{t-k})]}{E[(X_{t-k}-\hat EX_{t-k})^2]}$$
$$式中，\hat EX_t=E[X_t|X_{t-1},...,X_{t-k+1}],\hat EX_{t-k}=E[X_{t-k}|X_{t-1},...,X_{t-k+1}]$$
- 举例：假设平稳时间序列$y(t)$满足$y_t=0.1y_{t-1}+0.2y_{t-2}+\epsilon$，则：
  - 二阶偏自相关系数$\rho_2=0.2$（即系数本身。只考虑$y_t$与$y_{t-2}$之间，不考虑中间的$y_{t-1}$的情形）
  - 二阶自相关系数为$R_2=\frac{33}{80}$。由于$E[(y_t-\mu)(y_{t-2}-\mu)]=E[(0.1y_{y-1}+0.2y_{t-2}+\epsilon-\mu)(y_{t-2}-\mu)]=0.1E[(y_t-\mu)(y_{t-2}-\mu)]+0.2[(y_t-\mu)(y_{t-2}-\mu)]$，故$R_2=0.1R_1+0.2$。由于$E[(y_t-\mu)(y_{t-1}-\mu)]=E[(0.1y_{y-1}+0.2y_{t-2}+\epsilon-\mu)(y_{t-1}-\mu)]$，故$R_1=0.1+0.2R_1$，联立两式解得$R_1=\frac{1}{8},R_2=\frac{33}{80}$

### 2.2 *Shapiro-Wilk*检验
- 用于验证一个随机样本数据是否来自正态分布
- 设$Y_1< Y_2 < … < Y_n$是数量是$n$的一个排序的样本，需要验证其是否符合正态分布。假设是：
    - $H_0$: 样本数据与正态分布没有显著区别。
    - $H_A$: 样本数据与正态分布存在显著区别。
- 设定一显著性水平$α$（常见的是$0.05$），然后获得它的分位数或者临界值$W_α$，如果$W < W_α$则拒绝$H_0$，否则接受$H_0$。如果使用*p-value*，如果*p-value*小于显著性水平$α$，则拒绝$H_0$。

### 2.3 *SARIMA*模型
#### 2.3.1 定义
- **季节性差分自回归移动平均模型**S(*Seasonal Autoregressive Integrated Moving Average Model*)
- 在差分移动自回归模型(*ARIMA*)的基础上加上季节性(*S,Seasonal*)
- 适用于时间序列中带有明显周期性和季节性特征的数据
#### 2.3.2 差分
- 当数据序列不够平稳时，可以通过差分使得数据平稳
- 一次差分(*differencing*)：$y_t^*=y_t-y_{t-1}$
- 二次查分(*second order differencing*)：$y_t^*=(y_t-y_{t-1})-(y_{t-1}-y_{t-2})$
- 周期性差分(*seasonal differencing*)：数据点和前一个周期同一时间的数据点进行查分。
#### 2.3.3 模型特征
- *AR、MA、ARMA*的选择：
![AR、MA、ARMA的区分](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175516.png)
    - 拖尾：序列以指数率单调递减或震荡衰减
    - $d$阶截尾：序列从某个第d阶开始变得非常小
![](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175458.png)
- *S*（季节性）的选择：是否数据序列具有季节周期性
- *I*（差分）的选择：是否在处理数据平稳性时用到了差分
#### 2.3.4 训练流程
- **SARIMAX函数**(*Seasonal Autoregressive Integrated Moving-Average with Exogenous Regressors*)
  1. 根据时间序列的ADF检验结果判别其平稳性。
  2. 对非平稳的时间序列数据进行平稳化处理。直到处理后的自相关函数和偏自相关函数的数值非显著非零。
  3. 平稳化处理后，根据上表确定使用的模型。
  4. 参数估计，检验是否具有统计意义。
  5. 假设检验，判断(诊断)残差序列是否为白噪声序列。
  6. 利用已通过检验的模型进行预测。
![SARIMA算法流程](https://cdn.jsdelivr.net/gh/AmaneHayashi/PictureBed/20200630175535.png)
### 2.3.5 模型选择标准
- 模型选择问题在模型复杂度与模型对数据集描述能力（即似然函数）之间寻求最佳平衡。
- 人们提出许多信息准则，通过加入模型复杂度的惩罚项来避免过拟合问题，此处我们介绍一下常用的两个模型选择方法：
- 统计模型拟合优良性的常用标准：
  - *AIC(akaike information criterion)*：$AIC=-2ln(L) + 2k$
  - *BIC(bayesian information criterion)*：$BIC=-2ln(L) +kln(n)$
  - *HQ(hannan-quinn criterion)*：$HQ=-2ln(L) + kln(ln(n))$
  
  其中$L$是在该模型下的最大似然函数，$n$是数据数量，$k$是模型的变量个数
- 选择*AIC/BIC/HQ*最小的模型
### 2.4 误差函数
#### 2.4.1 *MAPE*函数
$$MAPE=\frac{100\%}{n}\Sigma_{i=1}^{n}|\frac{\hat y_i-y_i}{y_i}|$$
#### 2.4.2 *MAE*函数
$$MAE=\frac{1}{m}\Sigma_{i=1}^{m}|\hat y_i-y_i|$$

## 3. 代码分析

## 4. 论文建议
- 数据集来源、分析
- 采用*SARIMA*模型的理由(数学向)
- 算法伪代码
- 算法执行平台说明
- 预测结果与分析








